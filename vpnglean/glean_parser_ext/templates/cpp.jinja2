// -*- mode: C++ -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.
{# The rendered source is autogenerated, but this
Jinja2 template is not. Please file bugs! #}

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef mozilla_Metrics_h
#define mozilla_Metrics_h

#include "glean/metrictypes.h"

#include <QString>
#include <QObject>

{% for category_name, objs in all_objs.items() %}
class __DONOTUSE__{{ category_name|Camelize }} final {
  Q_GADGET

{% for obj in objs.values() %}
  Q_PROPERTY({{ obj|type_name }} {{obj.name|camelize }} READ {{ obj.name|camelize }} CONSTANT);
{% endfor %}

  public:
    {% for obj in objs.values() %}
    {{ obj|type_name }} {{obj.name|camelize }} () const { return m_{{obj.name|camelize }}; };
    {% endfor %}

  private:
    {% for obj in objs.values() %}
    {{ obj|type_name }} m_{{obj.name|camelize }} = {{ obj|type_name }}({{obj|metric_id}}{% if obj|attr("_generate_enums") %}, {{ get_next_event_extra_id() }}{% endif %});
    {% endfor %}
};
{% endfor %}

// This class is not meant to be used directly.
// It is exposed as a singleton to QML.
//
// The reason for this is to keep consistency with the Glean API on m-c.
// On JavaScript pings are accessed through GleanMetrics.<MyMetric> and
// on C++ they are accessed through mozilla::glean_pings::<my_metric>.
class __DONOTUSE__GleanMetrics final : public QObject {
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(__DONOTUSE__GleanMetrics)

    {% for category_name, _ in all_objs.items() %}
    Q_PROPERTY(__DONOTUSE__{{ category_name|Camelize }} {{ category_name|camelize }} READ {{ category_name|camelize }} CONSTANT);
    {% endfor %}

    private:
        __DONOTUSE__GleanMetrics() = default;

    public:
        ~__DONOTUSE__GleanMetrics() = default;

        static __DONOTUSE__GleanMetrics* instance() {
            if (!s_instance) {
                s_instance = new __DONOTUSE__GleanMetrics();
            }

            return s_instance;
        }

        {% for category_name, _ in all_objs.items() %}
        __DONOTUSE__{{ category_name|Camelize }} {{ category_name|camelize }} () const { return m_{{ category_name|camelize }}; };
        {% endfor %}

    private:
        {% for category_name, _ in all_objs.items() %}
        __DONOTUSE__{{ category_name|Camelize }} m_{{ category_name|camelize }} = __DONOTUSE__{{ category_name|Camelize }}() ;
        {% endfor %}

        inline static __DONOTUSE__GleanMetrics* s_instance = nullptr;
};

namespace mozilla::glean {

{%- macro generate_extra_keys(obj, id) -%}
{% for name, suffix in obj["_generate_enums"] %}
{# we always use the `extra` suffix, because we only expose the new event API #}
{% set suffix = "Extra" %}
{% if obj|attr(name)|length %}
    {% if obj.has_extra_types %}
    {{ extra_keys_with_types(obj, name, suffix, id)|indent }}
    {% else %}
#error "Untyped event extras not supported. Please annotate event extras with a type. See documentation for details. (Metric: {{obj.category}}.{{obj.name}}, defined in: {{obj.defined_in['filepath']}}:{{obj.defined_in['line']}})"
    {% endif %}
{% endif %}
{% endfor %}
{%- endmacro -%}

{%- macro extra_keys_with_types(obj, name, suffix, id) -%}
struct {{ obj.name|Camelize }}{{ suffix }} {
  {% for item, type in obj|attr(name) %}
  QVariant _{{ item|camelize }} = QVariant();
  {% endfor %}

  int __PRIVATE__id = {{ id }};

  FfiExtra ToFfiExtra(QList<QPair<QByteArray, QByteArray>>& keepStringsAlive) {
    const char* extraKeys[{{ obj|attr(name)|length }}];
    const char* extraValues[{{ obj|attr(name)|length }}];
    int count = 0;

    keepStringsAlive.clear();

    {% for item, type in obj|attr(name) %}
    if (_{{item|camelize}}.canConvert<{{type|extra_type_name}}>()) {
      {% if type == "string" %}
      QByteArray s = _{{item|camelize}}.toString().toUtf8();
      keepStringsAlive.append(QPair<QByteArray, QByteArray>(QByteArray(), s));
      extraValues[count] = s.constData();
      {% elif type == "boolean" %}
      extraValues[count] = _{{item|camelize}} ? "true" : "false";
      {% elif type == "quantity" %}
      QByteArray s = QString::number(_{{item|camelize}}.toInt()).toUtf8();
      extraValues[count] = s.constData();
      {% else %}
#error "Glean: Invalid extra key type for metric {{obj.category}}.{{obj.name}}, defined in: {{obj.defined_in['filepath']}}:{{obj.defined_in['line']}})"
      {% endif %}
      extraKeys[count] = "{{item}}";
      count++;
    }
    {% endfor %}

    FfiExtra extras;
    extras.keys = std::move(extraKeys);
    extras.values = std::move(extraValues);
    extras.count = count;
    return extras;
  };
};
{%- endmacro %}

{{ reset_event_extra_id_generator()|default("", True) }}

{% for category_name, objs in all_objs.items() %}
namespace {{ category_name|snake_case }} {
    {% for obj in objs.values() %}
    /**
     * generated from {{ category_name }}.{{ obj.name }}
     */
    {% if obj|attr("_generate_enums") %}
{{ generate_extra_keys(obj, get_next_event_extra_id()) }}
    {%- endif %}
    /**
     * {{ obj.description|wordwrap() | replace('\n', '\n     * ') }}
     */
    inline {{ obj|type_name }} {{obj.name|snake_case }} = __DONOTUSE__GleanMetrics::instance()->{{ category_name|camelize }}().{{ obj.name|camelize }}();

    {% endfor %}
}
{% endfor %}

} // namespace mozilla::glean

#endif // mozilla_Metrics_h
