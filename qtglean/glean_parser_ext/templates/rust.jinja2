// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.
{# The rendered source is autogenerated, but this
Jinja2 template is not. Please file bugs! #}

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#[allow(dead_code)]
use std::collections::HashMap;

use glean::traits::EventRecordingError;
use glean::RecordedEvent;
use once_cell::sync::Lazy;

{% macro generate_extra_keys(obj) -%}
{% for name, _ in obj["_generate_enums"] %}
{% set suffix = "Extra" %}
{% if obj|attr(name)|length %}
    {{ extra_keys_with_types(obj, name, suffix)|indent }}
{% endif %}
{% endfor %}
{%- endmacro -%}

{%- macro extra_keys_with_types(obj, name, suffix) -%}
#[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
pub struct {{ obj.name|Camelize }}{{ suffix }} {
    {% for item, type in obj|attr(name) %}
    pub r#{{ item|snake_case }}: Option<{{type|extra_type_name}}>,
    {% endfor %}
}

impl ExtraKeys for {{ obj.name|Camelize }}{{ suffix }} {
    const ALLOWED_KEYS: &'static [&'static str] = {{ obj.allowed_extra_keys|extra_keys }};

    fn into_ffi_extra(self) -> ::std::collections::HashMap<String, String> {
      let mut map = ::std::collections::HashMap::new();
      {% for key, _ in obj|attr(name) %}
      self.r#{{key|snake_case}}.and_then(|val| map.insert("{{key|snake_case}}".into(), val.to_string()));
      {% endfor %}
      map
    }
}
{%- endmacro -%}

{% for category_name, objs in all_objs.items() %}
pub mod {{ category_name|snake_case }} {
    use glean::private::*;
    #[allow(unused_imports)]
    use glean::{CommonMetricData, Lifetime, TimeUnit};
    #[allow(unused_imports)] // ExtraKeys might be unusued, let's avoid warnings
    use glean::traits::{ExtraKeys, NoExtraKeys};
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

    {% for obj in objs.values() %}
    {% if obj|attr("_generate_enums") %}
{{ generate_extra_keys(obj) }}
    {%- endif %}
    #[allow(non_upper_case_globals)]
    /// generated from {{ category_name }}.{{ obj.name }}
    ///
    /// {{ obj.description|wordwrap() | replace('\n', '\n    /// ') }}
    pub static {{ obj.name|snake_case }}: Lazy<{{ obj|type_name }}> = Lazy::new(|| {
        {{ obj|ctor }}(CommonMetricData {
            {% for arg_name in common_metric_data_args if obj[arg_name] is defined %}
            {{ arg_name }}: {{ obj[arg_name]|rust }},
            {% endfor %}
            ..Default::default()
        }
        {%- for arg_name in extra_args if obj[arg_name] is defined and arg_name not in common_metric_data_args and arg_name != 'allowed_extra_keys' -%}
            , {{ obj[arg_name]|rust }}
        {%- endfor -%}
        {{ ", " if obj.labeled else ")\n" }}
        {%- if obj.labeled -%}
        {%- if obj.labels -%}
        Some({{ obj.labels|rust }})
        {%- else -%}
        None
        {%- endif -%})
        {% endif %}
    });

    {% endfor %}
}
{% endfor %}

{% for typ, metrics in metric_by_type.items() %}
pub static {{typ.0}}: Lazy<HashMap<u32, &Lazy<glean::private::{{typ.1}}>>> = Lazy::new(|| {
    {% set map_ident = "_map" if metrics|length == 0 else "map" %}
    let mut {{map_ident}}: HashMap<u32, &Lazy<glean::private::{{typ.1}}>> = HashMap::with_capacity({{metrics|length}});
    {% for metric in metrics %}
    {{map_ident}}.insert({{metric.0}}, &{{metric.1}});
    {% endfor %}
    {{map_ident}}
});
{% endfor %}

/// Wrapper to record an event based on its metric ID.
///
/// # Arguments
///
/// * `metric_id` - The metric's ID to look up
/// * `extra`     - An map of (extra key id, string) pairs.
///                 The map will be decoded into the appropriate `ExtraKeys` type.
/// # Returns
///
/// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
/// or an `EventRecordingError::InvalidId` if no event by that ID exists
/// or an `EventRecordingError::InvalidExtraKey` if the `extra` map could not be deserialized.
pub(crate) fn record_event_by_id(metric_id: u32, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
    match metric_id {
{% for metric_id, event in events_by_id.items() %}
        {{metric_id}} => {
            {{event}}.record_with_time(glean::get_timestamp_ms(), extra);
            Ok(())
        }
{% endfor %}
        _ => Err(EventRecordingError::InvalidId),
    }
}

/// Wrapper to record an event based on its metric ID.
///
/// # Arguments
///
/// * `metric_id` - The metric's ID to look up.
///
/// # Returns
///
/// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
/// or an `EventRecordingError::InvalidId` if no event by that ID exists
/// or an `EventRecordingError::InvalidExtraKey` if the `extra` map could not be deserialized.
pub(crate) fn record_event_by_id_no_extra(metric_id: u32) -> Result<(), EventRecordingError> {
    match metric_id {
{% for metric_id, event in events_by_id.items() %}
        {{metric_id}} => {
            {{event}}.record(None);
            Ok(())
        }
{% endfor %}
        _ => Err(EventRecordingError::InvalidId),
    }
}

/// Wrapper to get the currently stored events for event metric.
///
/// # Arguments
///
/// * `metric_id` - The metric's ID to look up
/// * `ping_name` - (Optional) The ping name to look into.
///                 Defaults to the first value in `send_in_pings`.
///
/// # Returns
///
/// Returns the recorded events or `None` if nothing stored.
///
/// # Panics
///
/// Panics if no event by the given metric ID could be found.
pub(crate) fn event_test_get_value(metric_id: u32, ping_name: Option<String>) -> Option<Vec<RecordedEvent>> {
    match metric_id {
{% for metric_id, event in events_by_id.items() %}
        {{metric_id}} => {{event}}.test_get_value(ping_name.as_deref()),
{% endfor %}
        _ => panic!("No event for metric id {}", metric_id),
    }
}


/// Check the provided event for errors.
///
/// # Arguments
///
/// * `metric_id` - The metric's ID to look up
/// * `error_type` - The error to we want to get the count of.
///
/// # Returns
///
/// Returns the number of recorded errors of the requested type.
///
/// # Panics
///
/// Panics if no event by the given metric ID could be found.
#[allow(unused_variables)]
pub(crate) fn event_test_get_num_recorded_errors(metric_id: u32, error_type: glean_core::ErrorType) -> i32 {
    match metric_id {
{% for metric_id, event in events_by_id.items() %}
        {{metric_id}} => {{event}}.test_get_num_recorded_errors(error_type),
{% endfor %}
        _ => panic!("No event for metric id {}", metric_id),
    }
}
